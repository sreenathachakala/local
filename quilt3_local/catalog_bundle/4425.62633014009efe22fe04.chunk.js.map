{"version":3,"file":"4425.62633014009efe22fe04.chunk.js","mappings":"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","sources":["webpack://quilt-navigator/./app/containers/UriResolver/UriResolver.tsx","webpack://quilt-navigator/./app/utils/MetaTitle.tsx","webpack://quilt-navigator/./app/utils/PackageUri.ts"],"sourcesContent":["import * as React from 'react'\nimport { RouteComponentProps } from 'react-router'\nimport { useHistory, Redirect } from 'react-router-dom'\nimport * as M from '@material-ui/core'\n\nimport Layout from 'components/Layout'\nimport MetaTitle from 'utils/MetaTitle'\nimport * as NamedRoutes from 'utils/NamedRoutes'\nimport * as PackageUri from 'utils/PackageUri'\n\nconst useStyles = M.makeStyles((t) => ({\n  container: {\n    paddingTop: t.spacing(6),\n    paddingBottom: t.spacing(6),\n    maxWidth: '656px !important',\n  },\n  form: {\n    display: 'flex',\n    marginTop: t.spacing(3),\n  },\n  btn: {\n    marginLeft: t.spacing(2),\n  },\n}))\n\nexport default function UriResolver({ match }: RouteComponentProps<{ uri: string }>) {\n  const { urls } = NamedRoutes.use()\n  const history = useHistory()\n  const classes = useStyles()\n\n  const uri = decodeURIComponent(match.params.uri || '')\n  const [parsed, error] = React.useMemo(() => {\n    try {\n      return [uri ? PackageUri.parse(uri) : null]\n    } catch (e) {\n      return [null, e as unknown as PackageUri.PackageUriError]\n    }\n  }, [uri])\n\n  const [value, setValue] = React.useState(uri)\n\n  const handleChange = React.useCallback(\n    (e) => {\n      setValue(e.target.value)\n    },\n    [setValue],\n  )\n\n  const handleSubmit = React.useCallback(\n    (e) => {\n      e.preventDefault()\n      if (value !== uri) history.push(urls.uriResolver(value))\n    },\n    [value, uri, history, urls],\n  )\n\n  const to =\n    parsed &&\n    urls.bucketPackageTree(\n      parsed.bucket,\n      parsed.name,\n      parsed.hash || parsed.tag,\n      parsed.path,\n    ) + NamedRoutes.mkSearch({ resolvedFrom: uri })\n\n  if (to) return <Redirect to={to} />\n\n  return (\n    <Layout\n      pre={\n        <M.Container className={classes.container}>\n          <MetaTitle>Resolve a Quilt package URI</MetaTitle>\n\n          <M.Typography variant=\"h4\" align=\"center\">\n            Resolve a Quilt package URI\n          </M.Typography>\n\n          <form className={classes.form} onSubmit={handleSubmit}>\n            <M.Input\n              value={value}\n              onChange={handleChange}\n              error={!!error}\n              placeholder=\"Enter a URI, e.g. quilt+s3://your-bucket#package=user/package@hash\"\n              fullWidth\n            />\n            <M.Button\n              className={classes.btn}\n              type=\"submit\"\n              variant=\"contained\"\n              color=\"primary\"\n            >\n              Resolve\n            </M.Button>\n          </form>\n\n          {!!error && (\n            <M.Box mt={2}>\n              <M.Typography color=\"error\" data-testid=\"uri-error\">\n                Error parsing URI: {error.msg || `${error}`}\n              </M.Typography>\n            </M.Box>\n          )}\n        </M.Container>\n      }\n    />\n  )\n}\n","import * as React from 'react'\nimport { Helmet } from 'react-helmet'\n\nconst BASE = 'Quilt is a versioned data hub for AWS'\n\nconst DIVIDER = ' â€¢ '\n\ninterface MetaTitleProps {\n  children?: string | string[]\n  base?: string\n}\n\nfunction getTitleSegments(base: string, children?: string | string[]) {\n  if (!children) return [base]\n\n  if (Array.isArray(children)) return [...children, base]\n\n  return [children, base]\n}\n\nexport function getTitle(base: string, children?: string | string[]) {\n  return getTitleSegments(base, children).join(DIVIDER)\n}\n\nexport default function MetaTitle({ children, base = BASE }: MetaTitleProps) {\n  return (\n    <Helmet>\n      <title>{getTitle(base, children)}</title>\n    </Helmet>\n  )\n}\n","import { parse as parseQs } from 'querystring'\nimport { parse as parseUrl } from 'url'\n\nimport * as R from 'ramda'\n\nimport { BaseError } from 'utils/error'\n\nexport class PackageUriError extends BaseError {\n  static displayName = 'PackageUriError'\n\n  constructor(msg: string, uri: string) {\n    super(`Invalid package URI (${uri}): ${msg}`, { msg, uri })\n  }\n}\n\nexport interface PackageUri {\n  bucket: string\n  name: string\n  path?: string\n  hash?: string\n  tag?: string\n}\n\nfunction parsePackageSpec(spec: string, uri: string) {\n  if (spec.includes(':') && spec.includes('@')) {\n    throw new PackageUriError('\"package=\" part may either contain \":\" or \"@\".', uri)\n  }\n  if (spec.includes(':')) {\n    const [name, tag, ...rest] = spec.split(':')\n    if (!name) {\n      throw new PackageUriError(\n        '\"package=\" part must contain non-empty package name.',\n        uri,\n      )\n    }\n    if (!tag) {\n      throw new PackageUriError('\"package=\" part: tag must not be empty.', uri)\n    }\n    if (rest.length) {\n      throw new PackageUriError('\"package=\" part may contain only one \":\".', uri)\n    }\n    return { name, tag }\n  }\n  if (spec.includes('@')) {\n    const [name, hash, ...rest] = spec.split('@')\n    if (!name) {\n      throw new PackageUriError(\n        '\"package=\" part must contain non-empty package name.',\n        uri,\n      )\n    }\n    if (!hash) {\n      throw new PackageUriError('\"package=\" part: hash must not be empty.', uri)\n    }\n    if (rest.length) {\n      throw new PackageUriError('\"package=\" part may contain only one \"@\".', uri)\n    }\n    return { name, hash }\n  }\n  return { name: spec }\n}\n\n// TODO: do we need strict parsing here (throw on extra parameters)?\n// TODO: do we need extra validation for each part (package name, path, registry, etc)?\nexport function parse(uri: string): PackageUri {\n  const url = parseUrl(uri)\n  if (url.protocol !== 'quilt+s3:') {\n    throw new PackageUriError(\n      `unsupported protocol \"${url.protocol}\". \"quilt+s3:\" is currently the only supported protocol.`,\n      uri,\n    )\n  }\n  if (!url.slashes) {\n    throw new PackageUriError('missing slashes between protocol and registry.', uri)\n  }\n  if (url.path) {\n    throw new PackageUriError(\n      'non-bucket-root registries are not supported currently.',\n      uri,\n    )\n  }\n  const bucket = url.host\n  const params = parseQs((url.hash || '').replace('#', ''))\n  if (!params.package) {\n    throw new PackageUriError('missing \"package=\" part.', uri)\n  }\n  if (Array.isArray(params.package)) {\n    throw new PackageUriError('\"package=\" specified multiple times.', uri)\n  }\n  const { name, hash, tag } = parsePackageSpec(params.package, uri)\n  if (Array.isArray(params.path)) {\n    throw new PackageUriError('\"path=\" specified multiple times.', uri)\n  }\n  const path = params.path ? decodeURIComponent(params.path) : undefined\n  return R.reject(R.isNil, { bucket, name, hash, tag, path }) as unknown as PackageUri\n}\n\nexport function stringify({ bucket, name, hash, tag, path }: PackageUri) {\n  if (!bucket) throw new Error('PackageUri.stringify: missing \"bucket\"')\n  if (!name) throw new Error('PackageUri.stringify: missing \"name\"')\n  if (hash && tag) {\n    throw new Error(`PackageUri.stringify: can't have both \"hash\" and \"tag\"`)\n  }\n  let pkgSpec = name\n  if (hash) {\n    pkgSpec += `@${hash}`\n  } else if (tag) {\n    pkgSpec += `:${tag}`\n  }\n  const pathPart = path ? `&path=${encodeURIComponent(path)}` : ''\n  return `quilt+s3://${bucket}#package=${pkgSpec}${pathPart}`\n}\n"],"names":["useStyles","t","container","paddingTop","spacing","paddingBottom","maxWidth","form","display","marginTop","btn","marginLeft","UriResolver","match","urls","NamedRoutes","history","classes","uri","decodeURIComponent","params","PackageUri","e","parsed","error","value","setValue","handleChange","target","handleSubmit","preventDefault","push","uriResolver","to","bucketPackageTree","bucket","name","hash","tag","path","resolvedFrom","Layout","pre","className","MetaTitle","variant","align","onSubmit","onChange","placeholder","fullWidth","type","color","mt","msg","getTitle","base","children","Array","isArray","getTitleSegments","join","displayName","parse","url","protocol","PackageUriError","slashes","host","replace","package","spec","includes","split","rest","length","parsePackageSpec","undefined","stringify","Error","pkgSpec","pathPart","encodeURIComponent"],"sourceRoot":""}